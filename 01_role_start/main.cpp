#include <iostream>
#include "role.h"
#include "server.h"
using namespace std;

//从角色走路说起

//从玩家的角度来看，一款网络游戏大都会涉及如下流程：
//1）打开游戏，客户端向服务端发起网络连接。
//2）玩家输入账号密码，经过验证后，进入游戏场景。
//3）操作交互，比如行走、 打怪、 购买道具等。
//4）下线退出游戏。

//走路的五个步骤
//1、角色A移动
//2、客户端A向服务端发送新的坐标信息
//3、服务端处理消息
//4、服务端将角色A的新坐标发级客户端B
//5、客户端B收到消息并更新角色A的位置

//最少要掌握的三个概念
//1.IP和端口
//2.套接字
//3.Socket标识

//让角色走起来
//1）明确角色有哪些属性。
//2）做好建立和断开连接的处理。
//3）做好收到客户端数据的处理。

//单线事件模型
//Reactor模型
//单线事件模型。“单线”指的是单线程，“事件”指的是事件触发，即当新连接、断开连接、收到数据这些事件到来时会触发某段代码。


//三个层次的交互
//同一个进程内       交互代价很小，比如位置同步，同场景的角色数据可以直接获取，稳定性，最好
//同一台物理机       交互代价中等，2个程序位于同物理机上，之间通过网络消息交互数据，本机消息传输很快，比同进程内，直接读取内存要慢，稳定性，中等
//跨物理机          交互代价较大，网络传输毫秒级，速度慢，稳定性，差

//一致性问题


//万物皆Actor

//在Actor模型中，每个Actor相互隔离，只通过消息通信，具有天然的并发性。

//Actor模型的理念——万物皆Actor，它是更进一步的面向对象，即把世间万物都当作Actor对象。Actor可以代表一个角色、一只动物，也可以代表整个游戏场景

//每个Actor都会包含自身状态（HP、Coin），以及一个信箱（消息队列），Actor通过给其他Actor“寄信”来实现通信。至于收到信件后的反应，取决于收信的Actor。

//为什么说Actor模型适用于游戏开发呢？
//对游戏服务端而言，Actor并发模型给游戏业务的分割提供了灵活性。

int main(int argc, char *argv[]) {
    Server srv(argv[1], atoi(argv[2]));
    srv.start();
    return 0;
}